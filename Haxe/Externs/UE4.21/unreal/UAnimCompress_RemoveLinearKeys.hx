/**
 * 
 * WARNING! This file was autogenerated by: 
 *  _   _ _   _ __   __ 
 * | | | | | | |\ \ / / 
 * | | | | |_| | \ V /  
 * | | | |  _  | /   \  
 * | |_| | | | |/ /^\ \ 
 *  \___/\_| |_/\/   \/ 
 * 
 * This file was autogenerated by UnrealHxGenerator using UHT definitions.
 * It only includes UPROPERTYs and UFUNCTIONs. Do not modify it!
 * In order to add more definitions, create or edit a type with the same name/package, but with an `_Extra` suffix
**/
package unreal;

/**
  WARNING: This type was defined as MinimalAPI on its declaration. Because of that, its properties/methods are inaccessible
  
  
**/
@:glueCppIncludes("Animation/AnimCompress_RemoveLinearKeys.h")
@:uextern @:uclass extern class UAnimCompress_RemoveLinearKeys extends unreal.UAnimCompress {
  
  /**
    Whether or not to use multiple threads during compression.
  **/
  @:uproperty public var bUseMultithreading : Bool;
  
  /**
    Whether to use the legacy behavior that compressed and decompressed the whole sequence whenever a key was removed.
    This is left in for now in order to debug the code if issues arise with the new stateless version.
    The legacy behavior to compress the whole sequence constantly makes it impossible to compress segments
    in parallel safely. The new code samples the sequence without the compression step in order to make it
    thread safe.
    Once the stateless code is robust, this can be safely removed. It should never be used.
  **/
  @:uproperty public var bUseDecompression : Bool;
  
  /**
    UPROPERTY(EditAnywhere, Category = LinearKeyRemoval, meta = (EditCondition="bEnableSegmenting"))
  **/
  @:uproperty public var bOptimizeForForwardPlayback : Bool;
  
  /**
    Controls whether the final filtering step will occur, or only the retargetting after bitwise compression.
    If both this and bRetarget are false, then the linear compressor will do no better than the underlying bitwise compressor, extremely slowly.
  **/
  @:uproperty public var bActuallyFilterLinearKeys : Bool;
  
  /**
    true = As the animation is compressed, adjust animated nodes to compensate for compression error.
    false= Do not adjust animated nodes.
  **/
  @:uproperty public var bRetarget : Bool;
  
  /**
    A scale value which increases the likelihood that a bone will retain a key if it's parent also had a key at the same time position.
    Higher values can remove shaking artifacts from the animation, at the cost of compression.
  **/
  @:uproperty public var ParentKeyScale : unreal.Float32;
  
  /**
    Error threshold for End Effectors with Sockets attached to them.
    Typically more important bone, where we want to be less aggressive with compression.
  **/
  @:uproperty public var EffectorDiffSocket : unreal.Float32;
  
  /**
    As keys are tested for removal, we monitor the effects all the way down to the end effectors.
    If their position changes by more than this amount as a result of removing a key, the key will be retained.
    This value is used for the end-effectors parent, allowing tighter restrictions near the end of a skeletal chain.
  **/
  @:uproperty public var MinEffectorDiff : unreal.Float32;
  
  /**
    As keys are tested for removal, we monitor the effects all the way down to the end effectors.
    If their position changes by more than this amount as a result of removing a key, the key will be retained.
    This value is used for all bones except the end-effectors parent.
  **/
  @:uproperty public var MaxEffectorDiff : unreal.Float32;
  
  /**
    Maximum Scale difference to use when testing if an animation key may be removed. Lower values retain more keys, but yield less compression.
  **/
  @:uproperty public var MaxScaleDiff : unreal.Float32;
  
  /**
    Maximum angle difference to use when testing if an animation key may be removed. Lower values retain more keys, but yield less compression.
  **/
  @:uproperty public var MaxAngleDiff : unreal.Float32;
  
  /**
    Maximum position difference to use when testing if an animation key may be removed. Lower values retain more keys, but yield less compression.
  **/
  @:uproperty public var MaxPosDiff : unreal.Float32;
  
}
