/**
 * 
 * WARNING! This file was autogenerated by: 
 *  _   _ _   _ __   __ 
 * | | | | | | |\ \ / / 
 * | | | | |_| | \ V /  
 * | | | |  _  | /   \  
 * | |_| | | | |/ /^\ \ 
 *  \___/\_| |_/\/   \/ 
 * 
 * This file was autogenerated by UnrealHxGenerator using UHT definitions.
 * It only includes UPROPERTYs and UFUNCTIONs. Do not modify it!
 * In order to add more definitions, create or edit a type with the same name/package, but with an `_Extra` suffix
**/
package unreal.functionaltesting;

@:umodule("FunctionalTesting")
@:glueCppIncludes("Public/AutomationScreenshotOptions.h")
@:noCopy @:noEquals @:uextern @:ustruct extern class FAutomationScreenshotOptions {
  
  /**
    If this is true, all we compare is luminance of the scene.
  **/
  @:uproperty public var bIgnoreColors : Bool;
  
  /**
    If this is true, we search neighboring pixels looking for the expected pixel as what may have happened, is
    that the pixel shifted a little.
  **/
  @:uproperty public var bIgnoreAntiAliasing : Bool;
  
  /**
    After you've accounted for color tolerance changes, you now need to control for total acceptable error.
    Which depending on how pixels were colored on triangle edges may be a few percent of the image being
    outside the tolerance levels.
  **/
  @:uproperty public var MaximumGlobalError : unreal.Float32;
  
  /**
    After you've accounted for color tolerance changes, you now need to control for local acceptable error.
    Which depending on how pixels were colored on triangle edges may be a few percent of the image being
    outside the tolerance levels.  Unlike the MaximumGlobalError, the MaximumLocalError works by focusing
    on a smaller subset of the image.  These chunks will have be compared to the local error, in an attempt
    to locate hot spots of change that are important, that would be ignored by the global error.
  **/
  @:uproperty public var MaximumLocalError : unreal.Float32;
  
  /**
    For each channel and brightness levels you can control a region where the colors are found to be
    essentially the same.  Generally this is necessary as modern rendering techniques tend to introduce
    noise constantly to hide aliasing.
  **/
  @:uproperty public var ToleranceAmount : unreal.functionaltesting.FComparisonToleranceAmount;
  
  /**
    These are quick defaults for tolerance levels, we default to low, because generally there's some
    constant variability in every pixel's color introduced by TxAA.
  **/
  @:uproperty public var Tolerance : unreal.functionaltesting.EComparisonTolerance;
  
  /**
    Allows you to screenshot a buffer other than the default final lit scene image.  Useful if you're
    trying to build a test for a specific GBuffer, that may be harder to tell if errors are introduced
    in it.
  **/
  @:uproperty public var VisualizeBuffer : unreal.FName;
  
  /**
    Assign custom view settings to control which rendering options we allow on while taking the
    screenshot.
  **/
  @:uproperty public var ViewSettings : unreal.functionaltesting.UAutomationViewSettings;
  
  /**
    Disables Eye Adaptation and sets Tonemapper to fixed gamma curve. Should generally be on unless
    testing tone mapping or other post-processing results
  **/
  @:uproperty public var bDisableTonemapping : Bool;
  
  /**
    Disables Anti-Aliasing, Motion Blur, Screen Space Reflections, Eye Adaptation, Tonemapper and Contact
    Shadows, because those features contribute a lot to the noise in the final rendered image.  If you're
    explicitly looking for changes
  **/
  @:uproperty public var bDisableNoisyRenderingFeatures : Bool;
  
  /**
    Overrides World Time, Real Time to the value provided.  Sets Delta Time to 0.  Only
    affects the time being sent to the render thread and materials.  The time accumulating
    on the game thread is unaffected.
  **/
  @:uproperty public var OverrideTimeTo : unreal.Float32;
  @:uproperty public var bOverride_OverrideTimeTo : Bool;
  
  /**
    The delay before we take the screenshot.
  **/
  @:uproperty public var Delay : unreal.Float32;
  
  /**
    The desired resolution of the screenshot, if none is provided, it will use the default for the
    platform setup in the automation settings.
  **/
  @:uproperty public var Resolution : unreal.FVector2D;
  
}
