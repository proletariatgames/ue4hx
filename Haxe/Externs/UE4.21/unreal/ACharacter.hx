/**
 * 
 * WARNING! This file was autogenerated by: 
 *  _   _ _   _ __   __ 
 * | | | | | | |\ \ / / 
 * | | | | |_| | \ V /  
 * | | | |  _  | /   \  
 * | |_| | | | |/ /^\ \ 
 *  \___/\_| |_/\/   \/ 
 * 
 * This file was autogenerated by UnrealHxGenerator using UHT definitions.
 * It only includes UPROPERTYs and UFUNCTIONs. Do not modify it!
 * In order to add more definitions, create or edit a type with the same name/package, but with an `_Extra` suffix
**/
package unreal;

/**
  Characters are Pawns that have a mesh, collision, and built-in movement logic.
  They are responsible for all physical interaction between the player or AI and the world, and also implement basic networking and input models.
  They are designed for a vertically-oriented player representation that can walk, jump, fly, and swim through the world using CharacterMovementComponent.
  
  @see APawn, UCharacterMovementComponent
  @see https://docs.unrealengine.com/latest/INT/Gameplay/Framework/Pawn/Character/
**/
@:glueCppIncludes("GameFramework/Character.h")
@:uextern @:uclass extern class ACharacter extends unreal.APawn {
  
  /**
    Replicated Root Motion montage
  **/
  @:uproperty public var RepRootMotion : unreal.FRepRootMotionMontage;
  
  /**
    Array of previously received root motion moves from the server.
  **/
  @:uproperty public var RootMotionRepMoves : unreal.TArray<unreal.FSimulatedRootMotionReplicatedMove>;
  
  /**
    For LocallyControlled Autonomous clients. Saved root motion data to be used by SavedMoves.
  **/
  @:uproperty public var ClientRootMotionParams : unreal.FRootMotionMovementParams;
  
  /**
    For LocallyControlled Autonomous clients.
    During a PerformMovement() after root motion is prepared, we save it off into this and
    then record it into our SavedMoves.
    During SavedMove playback we use it as our "Previous Move" SavedRootMotion which includes
    last received root motion from the Server
  **/
  @:uproperty public var SavedRootMotion : unreal.FRootMotionSourceGroup;
  
  /**
    Event triggered at the end of a CharacterMovementComponent movement update.
    This is the preferred event to use rather than the Tick event when performing custom updates to CharacterMovement properties based on the current state.
    This is mainly due to the nature of network updates, where client corrections in position from the server can cause multiple iterations of a movement update,
    which allows this event to update as well, while a Tick event would not.
    
    @param       DeltaSeconds            Delta time in seconds for this update
    @param       InitialLocation         Location at the start of the update. May be different than the current location if movement occurred.
    @param       InitialVelocity         Velocity at the start of the update. May be different than the current velocity.
  **/
  @:uproperty public var OnCharacterMovementUpdated : unreal.FCharacterMovementUpdatedSignature;
  
  /**
    Multicast delegate for MovementMode changing.
  **/
  @:uproperty public var MovementModeChangedDelegate : unreal.FMovementModeChangedSignature;
  
  /**
    Broadcast when Character's jump reaches its apex. Needs CharacterMovement->bNotifyApex = true
  **/
  @:uproperty public var OnReachedJumpApex : unreal.FCharacterReachedApexSignature;
  
  /**
    Tracks the current number of jumps performed.
    This is incremented in CheckJumpInput, used in CanJump_Implementation, and reset in OnMovementModeChanged.
    When providing overrides for these methods, it's recommended to either manually
    increment / reset this value, or call the Super:: method.
  **/
  @:uproperty public var JumpCurrentCount : unreal.Int32;
  
  /**
    The max number of jumps the character can perform.
    Note that if JumpMaxHoldTime is non zero and StopJumping is not called, the player
    may be able to perform and unlimited number of jumps. Therefore it is usually
    best to call StopJumping() when jump input has ceased (such as a button up event).
  **/
  @:uproperty public var JumpMaxCount : unreal.Int32;
  
  /**
    The max time the jump key can be held.
    Note that if StopJumping() is not called before the max jump hold time is reached,
    then the character will carry on receiving vertical velocity. Therefore it is usually
    best to call StopJumping() when jump input has ceased (such as a button up event).
  **/
  @:uproperty public var JumpMaxHoldTime : unreal.Float32;
  
  /**
    Track last time a jump force started for a proxy.
  **/
  @:uproperty public var ProxyJumpForceStartedTime : unreal.Float32;
  
  /**
    Amount of jump force time remaining, if JumpMaxHoldTime > 0.
  **/
  @:uproperty public var JumpForceTimeRemaining : unreal.Float32;
  
  /**
    Jump key Held Time.
    This is the time that the player has held the jump key, in seconds.
  **/
  @:uproperty public var JumpKeyHoldTime : unreal.Float32;
  
  /**
    Tracks whether or not the character was already jumping last frame.
  **/
  @:uproperty public var bWasJumping : Bool;
  
  /**
    Disable root motion on the server. When receiving a DualServerMove, where the first move is not root motion and the second is.
  **/
  @:uproperty public var bServerMoveIgnoreRootMotion : Bool;
  @:uproperty public var bClientCheckEncroachmentOnNetUpdate : Bool;
  
  /**
    Disable simulated gravity (set when character encroaches geometry on client, to keep him from falling through floors)
  **/
  @:uproperty public var bSimGravityDisabled : Bool;
  
  /**
    If server disagrees with root motion state, client has to resimulate root motion from last AckedMove.
  **/
  @:uproperty public var bClientResimulateRootMotionSources : Bool;
  
  /**
    If server disagrees with root motion track position, client has to resimulate root motion from last AckedMove.
  **/
  @:uproperty public var bClientResimulateRootMotion : Bool;
  
  /**
    True if Pawn was initially falling when started to replay network moves.
  **/
  @:uproperty public var bClientWasFalling : Bool;
  
  /**
    When true, applying updates to network client (replaying saved moves for a locally controlled character)
  **/
  @:uproperty public var bClientUpdating : Bool;
  
  /**
    When true, player wants to jump
  **/
  @:uproperty public var bPressedJump : Bool;
  
  /**
    Set to indicate that this Character is currently under the force of a jump (if JumpMaxHoldTime is non-zero). IsJumpProvidingForce() handles this as well.
  **/
  @:uproperty public var bProxyIsJumpForceApplied : Bool;
  
  /**
    Set by character movement to specify that this Character is currently crouched.
  **/
  @:uproperty public var bIsCrouched : Bool;
  
  /**
    Default crouched eye height
  **/
  @:uproperty public var CrouchedEyeHeight : unreal.Float32;
  
  /**
    CharacterMovement MovementMode (and custom mode) replicated for simulated proxies. Use CharacterMovementComponent::UnpackNetworkMovementMode() to translate it.
  **/
  @:uproperty private var ReplicatedMovementMode : unreal.UInt8;
  @:uproperty private var ReplayLastTransformUpdateTimeStamp : unreal.Float32;
  
  /**
    CharacterMovement ServerLastTransformUpdateTimeStamp value, replicated to simulated proxies.
  **/
  @:uproperty private var ReplicatedServerLastTransformUpdateTimeStamp : unreal.Float32;
  
  /**
    Saved rotation offset of mesh.
  **/
  @:uproperty private var BaseRotationOffset : unreal.FQuat;
  
  /**
    Saved translation offset of mesh.
  **/
  @:uproperty private var BaseTranslationOffset : unreal.FVector;
  
  /**
    Scale to apply to root motion translation on this Character
  **/
  @:uproperty private var AnimRootMotionTranslationScale : unreal.Float32;
  
  /**
    Replicated version of relative movement. Read-only on simulated proxies!
  **/
  @:uproperty private var ReplicatedBasedMovement : unreal.FBasedMovementInfo;
  
  /**
    Info about our current movement base (object we are standing on).
  **/
  @:uproperty private var BasedMovement : unreal.FBasedMovementInfo;
  
  /**
    Replicated function sent by client to server - contains client movement and view info.
  **/
  @:ufunction(Server) public function ServerMove(TimeStamp : unreal.Float32, InAccel : unreal.FVector_NetQuantize10, ClientLoc : unreal.FVector_NetQuantize100, CompressedMoveFlags : unreal.UInt8, ClientRoll : unreal.UInt8, View : unreal.FakeUInt32, ClientMovementBase : unreal.UPrimitiveComponent, ClientBaseBoneName : unreal.FName, ClientMovementMode : unreal.UInt8) : Void;
  
  /**
    Replicated function sent by client to server. Saves bandwidth over ServerMove() by implying that ClientMovementBase and ClientBaseBoneName are null.
    Passes through to CharacterMovement->ServerMove_Implementation() with null base params.
  **/
  @:ufunction(Server) public function ServerMoveNoBase(TimeStamp : unreal.Float32, InAccel : unreal.FVector_NetQuantize10, ClientLoc : unreal.FVector_NetQuantize100, CompressedMoveFlags : unreal.UInt8, ClientRoll : unreal.UInt8, View : unreal.FakeUInt32, ClientMovementMode : unreal.UInt8) : Void;
  
  /**
    Replicated function sent by client to server - contains client movement and view info for two moves.
  **/
  @:ufunction(Server) public function ServerMoveDual(TimeStamp0 : unreal.Float32, InAccel0 : unreal.FVector_NetQuantize10, PendingFlags : unreal.UInt8, View0 : unreal.FakeUInt32, TimeStamp : unreal.Float32, InAccel : unreal.FVector_NetQuantize10, ClientLoc : unreal.FVector_NetQuantize100, NewFlags : unreal.UInt8, ClientRoll : unreal.UInt8, View : unreal.FakeUInt32, ClientMovementBase : unreal.UPrimitiveComponent, ClientBaseBoneName : unreal.FName, ClientMovementMode : unreal.UInt8) : Void;
  
  /**
    Replicated function sent by client to server - contains client movement and view info for two moves.
  **/
  @:ufunction(Server) public function ServerMoveDualNoBase(TimeStamp0 : unreal.Float32, InAccel0 : unreal.FVector_NetQuantize10, PendingFlags : unreal.UInt8, View0 : unreal.FakeUInt32, TimeStamp : unreal.Float32, InAccel : unreal.FVector_NetQuantize10, ClientLoc : unreal.FVector_NetQuantize100, NewFlags : unreal.UInt8, ClientRoll : unreal.UInt8, View : unreal.FakeUInt32, ClientMovementMode : unreal.UInt8) : Void;
  
  /**
    Replicated function sent by client to server - contains client movement and view info for two moves. First move is non root motion, second is root motion.
  **/
  @:ufunction(Server) public function ServerMoveDualHybridRootMotion(TimeStamp0 : unreal.Float32, InAccel0 : unreal.FVector_NetQuantize10, PendingFlags : unreal.UInt8, View0 : unreal.FakeUInt32, TimeStamp : unreal.Float32, InAccel : unreal.FVector_NetQuantize10, ClientLoc : unreal.FVector_NetQuantize100, NewFlags : unreal.UInt8, ClientRoll : unreal.UInt8, View : unreal.FakeUInt32, ClientMovementBase : unreal.UPrimitiveComponent, ClientBaseBoneName : unreal.FName, ClientMovementMode : unreal.UInt8) : Void;
  
  /**
    Resending an (important) old move. Process it if not already processed.
  **/
  @:ufunction(Server) public function ServerMoveOld(OldTimeStamp : unreal.Float32, OldAccel : unreal.FVector_NetQuantize10, OldMoveFlags : unreal.UInt8) : Void;
  
  /**
    If no client adjustment is needed after processing received ServerMove(), ack the good move so client can remove it from SavedMoves
  **/
  @:ufunction(Client) public function ClientAckGoodMove(TimeStamp : unreal.Float32) : Void;
  
  /**
    Replicate position correction to client, associated with a timestamped servermove.  Client will replay subsequent moves after applying adjustment.
  **/
  @:ufunction(Client) public function ClientAdjustPosition(TimeStamp : unreal.Float32, NewLoc : unreal.FVector, NewVel : unreal.FVector, NewBase : unreal.UPrimitiveComponent, NewBaseBoneName : unreal.FName, bHasBase : Bool, bBaseRelativePosition : Bool, ServerMovementMode : unreal.UInt8) : Void;
  
  /**
    Bandwidth saving version, when velocity is zeroed
  **/
  @:ufunction(Client) public function ClientVeryShortAdjustPosition(TimeStamp : unreal.Float32, NewLoc : unreal.FVector, NewBase : unreal.UPrimitiveComponent, NewBaseBoneName : unreal.FName, bHasBase : Bool, bBaseRelativePosition : Bool, ServerMovementMode : unreal.UInt8) : Void;
  
  /**
    Replicate position correction to client when using root motion for movement. (animation root motion specific)
  **/
  @:ufunction(Client) public function ClientAdjustRootMotionPosition(TimeStamp : unreal.Float32, ServerMontageTrackPosition : unreal.Float32, ServerLoc : unreal.FVector, ServerRotation : unreal.FVector_NetQuantizeNormal, ServerVelZ : unreal.Float32, ServerBase : unreal.UPrimitiveComponent, ServerBoneName : unreal.FName, bHasBase : Bool, bBaseRelativePosition : Bool, ServerMovementMode : unreal.UInt8) : Void;
  
  /**
    Replicate root motion source correction to client when using root motion for movement.
  **/
  @:ufunction(Client) public function ClientAdjustRootMotionSourcePosition(TimeStamp : unreal.Float32, ServerRootMotion : unreal.FRootMotionSourceGroup, bHasAnimRootMotion : Bool, ServerMontageTrackPosition : unreal.Float32, ServerLoc : unreal.FVector, ServerRotation : unreal.FVector_NetQuantizeNormal, ServerVelZ : unreal.Float32, ServerBase : unreal.UPrimitiveComponent, ServerBoneName : unreal.FName, bHasBase : Bool, bBaseRelativePosition : Bool, ServerMovementMode : unreal.UInt8) : Void;
  
  /**
    Cache mesh offset from capsule. This is used as the target for network smoothing interpolation, when the mesh is offset with lagged smoothing.
    This is automatically called during initialization; call this at runtime if you intend to change the default mesh offset from the capsule.
    @see GetBaseTranslationOffset(), GetBaseRotationOffset()
  **/
  @:ufunction(BlueprintCallable) public function CacheInitialMeshOffset(MeshRelativeLocation : unreal.FVector, MeshRelativeRotation : unreal.FRotator) : Void;
  
  /**
    Rep notify for ReplicatedBasedMovement
  **/
  @:ufunction public function OnRep_ReplicatedBasedMovement() : Void;
  @:ufunction @:final public function OnRep_ReplayLastTransformUpdateTimeStamp() : Void;
  
  /**
    Get the saved translation offset of mesh. This is how much extra offset is applied from the center of the capsule.
  **/
  @:ufunction(BlueprintCallable) @:thisConst @:final public function GetBaseTranslationOffset() : unreal.FVector;
  
  /**
    Get the saved rotation offset of mesh. This is how much extra rotation is applied from the capsule rotation.
  **/
  @:ufunction(BlueprintCallable) @:thisConst @:final public function GetBaseRotationOffsetRotator() : unreal.FRotator;
  
  /**
    Handle Crouching replicated from server
  **/
  @:ufunction public function OnRep_IsCrouched() : Void;
  
  /**
    Make the character jump on the next update.
    If you want your character to jump according to the time that the jump key is held,
    then you can set JumpKeyHoldTime to some non-zero value. Make sure in this case to
    call StopJumping() when you want the jump's z-velocity to stop being applied (such
    as on a button up event), otherwise the character will carry on receiving the
    velocity until JumpKeyHoldTime is reached.
  **/
  @:ufunction(BlueprintCallable) public function Jump() : Void;
  
  /**
    Stop the character from jumping on the next update.
    Call this from an input event (such as a button 'up' event) to cease applying
    jump Z-velocity. If this is not called, then jump z-velocity will be applied
    until JumpMaxHoldTime is reached.
  **/
  @:ufunction(BlueprintCallable) public function StopJumping() : Void;
  
  /**
    Check if the character can jump in the current state.
    
    The default implementation may be overridden or extended by implementing the custom CanJump event in Blueprints.
    
    @Return Whether the character can jump in the current state.
  **/
  @:ufunction(BlueprintCallable) @:thisConst @:final public function CanJump() : Bool;
  
  /**
    Customizable event to check if the character can jump in the current state.
    Default implementation returns true if the character is on the ground and not crouching,
    has a valid CharacterMovementComponent and CanEverJump() returns true.
    Default implementation also allows for 'hold to jump higher' functionality:
    As well as returning true when on the ground, it also returns true when GetMaxJumpTime is more
    than zero and IsJumping returns true.
    
    
    @Return Whether the character can jump in the current state.
  **/
  @:ufunction(BlueprintNativeEvent) @:thisConst private function CanJumpInternal() : Bool;
  
  /**
    True if jump is actively providing a force, such as when the jump key is held and the time it has been held is less than JumpMaxHoldTime.
    @see CharacterMovement->IsFalling
  **/
  @:ufunction(BlueprintCallable) @:thisConst public function IsJumpProvidingForce() : Bool;
  
  /**
    Play Animation Montage on the character mesh *
  **/
  @:ufunction(BlueprintCallable) public function PlayAnimMontage(AnimMontage : unreal.UAnimMontage, InPlayRate : unreal.Float32 = 1.000000, @:opt("None") StartSectionName : unreal.FName) : unreal.Float32;
  
  /**
    Stop Animation Montage. If nullptr, it will stop what's currently active. The Blend Out Time is taken from the montage asset that is being stopped. *
  **/
  @:ufunction(BlueprintCallable) public function StopAnimMontage(@:opt("None") AnimMontage : unreal.UAnimMontage) : Void;
  
  /**
    Return current playing Montage *
  **/
  @:ufunction(BlueprintCallable) @:final public function GetCurrentMontage() : unreal.UAnimMontage;
  
  /**
    Set a pending launch velocity on the Character. This velocity will be processed on the next CharacterMovementComponent tick,
    and will set it to the "falling" state. Triggers the OnLaunched event.
    @PARAM LaunchVelocity is the velocity to impart to the Character
    @PARAM bXYOverride if true replace the XY part of the Character's velocity instead of adding to it.
    @PARAM bZOverride if true replace the Z component of the Character's velocity instead of adding to it.
  **/
  @:ufunction(BlueprintCallable) public function LaunchCharacter(LaunchVelocity : unreal.FVector, bXYOverride : Bool, bZOverride : Bool) : Void;
  
  /**
    Let blueprint know that we were launched
  **/
  @:ufunction(BlueprintImplementableEvent) public function OnLaunched(LaunchVelocity : unreal.FVector, bXYOverride : Bool, bZOverride : Bool) : Void;
  
  /**
    Event fired when the character has just started jumping
  **/
  @:ufunction(BlueprintNativeEvent) public function OnJumped() : Void;
  
  /**
    Called upon landing when falling, to perform actions based on the Hit result.
    Note that movement mode is still "Falling" during this event. Current Velocity value is the velocity at the time of landing.
    Consider OnMovementModeChanged() as well, as that can be used once the movement mode changes to the new mode (most likely Walking).
    
    @param Hit Result describing the landing that resulted in a valid landing spot.
    @see OnMovementModeChanged()
  **/
  @:ufunction(BlueprintImplementableEvent) public function OnLanded(Hit : unreal.Const<unreal.PRef<unreal.FHitResult>>) : Void;
  
  /**
    Event fired when the Character is walking off a surface and is about to fall because CharacterMovement->CurrentFloor became unwalkable.
    If CharacterMovement->MovementMode does not change during this event then the character will automatically start falling afterwards.
    @note Z velocity is zero during walking movement, and will be here as well. Another velocity can be computed here if desired and will be used when starting to fall.
    
    @param  PreviousFloorImpactNormal Normal of the previous walkable floor.
    @param  PreviousFloorContactNormal Normal of the contact with the previous walkable floor.
    @param  PreviousLocation     Previous character location before movement off the ledge.
    @param  TimeTick     Time delta of movement update resulting in moving off the ledge.
  **/
  @:ufunction(BlueprintNativeEvent) public function OnWalkingOffLedge(PreviousFloorImpactNormal : unreal.Const<unreal.PRef<unreal.FVector>>, PreviousFloorContactNormal : unreal.Const<unreal.PRef<unreal.FVector>>, PreviousLocation : unreal.Const<unreal.PRef<unreal.FVector>>, TimeDelta : unreal.Float32) : Void;
  
  /**
    Request the character to start crouching. The request is processed on the next update of the CharacterMovementComponent.
    @see OnStartCrouch
    @see IsCrouched
    @see CharacterMovement->WantsToCrouch
  **/
  @:ufunction(BlueprintCallable) public function Crouch(bClientSimulation : Bool = false) : Void;
  
  /**
    Request the character to stop crouching. The request is processed on the next update of the CharacterMovementComponent.
    @see OnEndCrouch
    @see IsCrouched
    @see CharacterMovement->WantsToCrouch
  **/
  @:ufunction(BlueprintCallable) public function UnCrouch(bClientSimulation : Bool = false) : Void;
  
  /**
    Event when Character stops crouching.
    @param       HalfHeightAdjust                difference between default collision half-height, and actual crouched capsule half-height.
    @param       ScaledHalfHeightAdjust  difference after component scale is taken in to account.
  **/
  @:ufunction(BlueprintImplementableEvent) public function K2_OnEndCrouch(HalfHeightAdjust : unreal.Float32, ScaledHalfHeightAdjust : unreal.Float32) : Void;
  
  /**
    Event when Character crouches.
    @param       HalfHeightAdjust                difference between default collision half-height, and actual crouched capsule half-height.
    @param       ScaledHalfHeightAdjust  difference after component scale is taken in to account.
  **/
  @:ufunction(BlueprintImplementableEvent) public function K2_OnStartCrouch(HalfHeightAdjust : unreal.Float32, ScaledHalfHeightAdjust : unreal.Float32) : Void;
  
  /**
    Called from CharacterMovementComponent to notify the character that the movement mode has changed.
    @param       PrevMovementMode        Movement mode before the change
    @param       NewMovementMode         New movement mode
    @param       PrevCustomMode          Custom mode before the change (applicable if PrevMovementMode is Custom)
    @param       NewCustomMode           New custom mode (applicable if NewMovementMode is Custom)
  **/
  @:ufunction(BlueprintImplementableEvent) public function K2_OnMovementModeChanged(PrevMovementMode : unreal.EMovementMode, NewMovementMode : unreal.EMovementMode, PrevCustomMode : unreal.UInt8, NewCustomMode : unreal.UInt8) : Void;
  
  /**
    Event for implementing custom character movement mode. Called by CharacterMovement if MovementMode is set to Custom.
    @note C++ code should override UCharacterMovementComponent::PhysCustom() instead.
    @see UCharacterMovementComponent::PhysCustom()
  **/
  @:ufunction(BlueprintImplementableEvent) public function K2_UpdateCustomMovement(DeltaTime : unreal.Float32) : Void;
  @:ufunction(Client) public function ClientCheatWalk() : Void;
  @:ufunction(Client) public function ClientCheatFly() : Void;
  @:ufunction(Client) public function ClientCheatGhost() : Void;
  @:ufunction(Client) public function RootMotionDebugClientPrintOnScreen(InString : unreal.FString) : Void;
  
  /**
    Handles replicated root motion properties on simulated proxies and position correction.
  **/
  @:ufunction @:final public function OnRep_RootMotion() : Void;
  
  /**
    True if we are playing Root Motion right now
  **/
  @:ufunction(BlueprintCallable) @:thisConst @:final public function IsPlayingRootMotion() : Bool;
  
  /**
    True if we are playing Root Motion right now, through a Montage with RootMotionMode == ERootMotionMode::RootMotionFromMontagesOnly.
    This means code path for networked root motion is enabled.
  **/
  @:ufunction(BlueprintCallable) @:thisConst @:final public function IsPlayingNetworkedRootMotionMontage() : Bool;
  
  /**
    Returns current value of AnimRootMotionScale
  **/
  @:ufunction(BlueprintCallable) @:thisConst @:final public function GetAnimRootMotionTranslationScale() : unreal.Float32;
  
}
