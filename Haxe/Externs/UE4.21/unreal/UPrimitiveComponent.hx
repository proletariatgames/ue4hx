/**
 * 
 * WARNING! This file was autogenerated by: 
 *  _   _ _   _ __   __ 
 * | | | | | | |\ \ / / 
 * | | | | |_| | \ V /  
 * | | | |  _  | /   \  
 * | |_| | | | |/ /^\ \ 
 *  \___/\_| |_/\/   \/ 
 * 
 * This file was autogenerated by UnrealHxGenerator using UHT definitions.
 * It only includes UPROPERTYs and UFUNCTIONs. Do not modify it!
 * In order to add more definitions, create or edit a type with the same name/package, but with an `_Extra` suffix
**/
package unreal;

/**
  PrimitiveComponents are SceneComponents that contain or generate some sort of geometry, generally to be rendered or used as collision data.
  There are several subclasses for the various types of geometry, but the most common by far are the ShapeComponents (Capsule, Sphere, Box), StaticMeshComponent, and SkeletalMeshComponent.
  ShapeComponents generate geometry that is used for collision detection but are not rendered, while StaticMeshComponents and SkeletalMeshComponents contain pre-built geometry that is rendered, but can also be used for collision detection.
**/
@:glueCppIncludes("Components/PrimitiveComponent.h")
@:uextern @:uclass extern class UPrimitiveComponent extends unreal.USceneComponent implements unreal.INavRelevantInterface {
  
  /**
    Tick function for physics ticking *
  **/
  @:uproperty public var PostPhysicsComponentTick(default,never) : unreal.FPrimitiveComponentPostPhysicsTickFunction;
  
  /**
    Event called when a finger is moved off this component when touch over events are enabled in the player controller
  **/
  @:uproperty public var OnInputTouchLeave : unreal.FComponentEndTouchOverSignature;
  
  /**
    Event called when a finger is moved over this component when touch over events are enabled in the player controller
  **/
  @:uproperty public var OnInputTouchEnter : unreal.FComponentBeginTouchOverSignature;
  
  /**
    Event called when a touch input is released over this component when touch events are enabled in the player controller
  **/
  @:uproperty public var OnInputTouchEnd : unreal.FComponentOnInputTouchEndSignature;
  
  /**
    Event called when a touch input is received over this component when touch events are enabled in the player controller
  **/
  @:uproperty public var OnInputTouchBegin : unreal.FComponentOnInputTouchBeginSignature;
  
  /**
    Event called when the left mouse button is released while the mouse is over this component click events are enabled in the player controller
  **/
  @:uproperty public var OnReleased : unreal.FComponentOnReleasedSignature;
  
  /**
    Event called when the left mouse button is clicked while the mouse is over this component and click events are enabled in the player controller
  **/
  @:uproperty public var OnClicked : unreal.FComponentOnClickedSignature;
  
  /**
    Event called when the mouse cursor is moved off this component and mouse over events are enabled in the player controller
  **/
  @:uproperty public var OnEndCursorOver : unreal.FComponentEndCursorOverSignature;
  
  /**
    Event called when the mouse cursor is moved over this component and mouse over events are enabled in the player controller
  **/
  @:uproperty public var OnBeginCursorOver : unreal.FComponentBeginCursorOverSignature;
  
  /**
    Event called when the underlying physics objects is put to sleep
  **/
  @:uproperty public var OnComponentSleep : unreal.FComponentSleepSignature;
  
  /**
    Event called when the underlying physics objects is woken up
  **/
  @:uproperty public var OnComponentWake : unreal.FComponentWakeSignature;
  
  /**
    Event called when something stops overlapping this component
    @note Both this component and the other one must have GetGenerateOverlapEvents() set to true to generate overlap events.
  **/
  @:uproperty public var OnComponentEndOverlap : unreal.FComponentEndOverlapSignature;
  
  /**
    Event called when something starts to overlaps this component, for example a player walking into a trigger.
    For events when objects have a blocking collision, for example a player hitting a wall, see 'Hit' events.
    
    @note Both this component and the other one must have GetGenerateOverlapEvents() set to true to generate overlap events.
    @note When receiving an overlap from another object's movement, the directions of 'Hit.Normal' and 'Hit.ImpactNormal'
    will be adjusted to indicate force from the other object against this object.
  **/
  @:uproperty public var OnComponentBeginOverlap : unreal.FComponentBeginOverlapSignature;
  
  /**
    Event called when a component hits (or is hit by) something solid. This could happen due to things like Character movement, using Set Location with 'sweep' enabled, or physics simulation.
    For events when objects overlap (e.g. walking into a trigger) see the 'Overlap' event.
    
    @note For collisions during physics simulation to generate hit events, 'Simulation Generates Hit Events' must be enabled for this component.
    @note When receiving a hit from another object's movement, the directions of 'Hit.Normal' and 'Hit.ImpactNormal'
    will be adjusted to indicate force from the other object against this object.
    @note NormalImpulse will be filled in for physics-simulating bodies, but will be zero for swept-component blocking collisions.
  **/
  @:uproperty public var OnComponentHit : unreal.FComponentHitSignature;
  
  /**
    Physics scene information for this component, holds a single rigid body with multiple shapes.
  **/
  @:uproperty public var BodyInstance(default,never) : unreal.FBodyInstance;
  
  /**
    Set of components to ignore during component sweeps in MoveComponent().
    These components will be ignored when this component moves or updates overlaps.
    The other components may also need to be told to do the same when they move.
    Does not affect movement of this component when simulating physics.
    @see IgnoreComponentWhenMoving()
  **/
  @:uproperty public var MoveIgnoreComponents : unreal.TArray<unreal.UPrimitiveComponent>;
  
  /**
    Set of actors to ignore during component sweeps in MoveComponent().
    All components owned by these actors will be ignored when this component moves or updates overlaps.
    Components on the other Actor may also need to be told to do the same when they move.
    Does not affect movement of this component when simulating physics.
    @see IgnoreActorWhenMoving()
  **/
  @:uproperty public var MoveIgnoreActors : unreal.TArray<unreal.AActor>;
  @:uproperty public var LastRenderTimeOnScreen : unreal.Float32;
  
  /**
    The value of WorldSettings->TimeSeconds for the frame when this component was last rendered.  This is written
    from the render thread, which is up to a frame behind the game thread, so you should allow this time to
    be at least a frame behind the game thread's world time before you consider the actor non-visible.
  **/
  @:uproperty public var LastRenderTime : unreal.Float32;
  
  /**
    Last time the component was submitted for rendering (called FScene::AddPrimitive).
  **/
  @:uproperty public var LastSubmitTime : unreal.Float32;
  
  /**
    Scales the bounds of the object.
    This is useful when using World Position Offset to animate the vertices of the object outside of its bounds.
    Warning: Increasing the bounds of an object will reduce performance and shadow quality!
    Currently only used by StaticMeshComponent and SkeletalMeshComponent.
  **/
  @:uproperty public var BoundsScale : unreal.Float32;
  
  /**
    Multiplier used to scale the Light Propagation Volume light injection bias, to reduce light bleeding.
    Set to 0 for no bias, 1 for default or higher for increased biasing (e.g. for
    thin geometry such as walls)
  **/
  @:uproperty public var LpvBiasMultiplier : unreal.Float32;
  
  /**
    Used for precomputed visibility
  **/
  @:uproperty public var VisibilityId : unreal.Int32;
  
  /**
    Translucent objects with a lower sort priority draw behind objects with a higher priority.
    Translucent objects with the same priority are rendered from back-to-front based on their bounds origin.
    
    Ignored if the object is not translucent.  The default priority is zero.
    Warning: This should never be set to a non-default value unless you know what you are doing, as it will prevent the renderer from sorting correctly.
    It is especially problematic on dynamic gameplay effects.
  **/
  @:uproperty public var TranslucencySortPriority : unreal.Int32;
  
  /**
    Optionally write this 0-255 value to the stencil buffer in CustomDepth pass (Requires project setting or r.CustomDepth == 3)
  **/
  @:uproperty public var CustomDepthStencilValue : unreal.Int32;
  
  /**
    Mask used for stencil buffer writes.
  **/
  @:uproperty public var CustomDepthStencilWriteMask : unreal.ERendererStencilMask;
  
  /**
    Channels that this component should be in.  Lights with matching channels will affect the component.
    These channels only apply to opaque materials, direct lighting, and dynamic lighting and shadowing.
  **/
  @:uproperty public var LightingChannels : unreal.FLightingChannels;
  
  /**
    Determine whether a Character can step up onto this component.
    This controls whether they can try to step up on it when they bump in to it, not whether they can walk on it after landing on it.
    @see FWalkableSlopeOverride
  **/
  @:uproperty public var CanCharacterStepUpOn : unreal.ECanBeCharacterBase;
  
  /**
    If true then DoCustomNavigableGeometryExport will be called to collect navigable geometry of this component.
  **/
  @:uproperty public var bHasCustomNavigableGeometry : unreal.EHasCustomNavigableGeometry;
  
  /**
    If true, this component will be rendered in the CustomDepth pass (usually used for outlines)
  **/
  @:uproperty public var bRenderCustomDepth : Bool;
  
  /**
    Composite the drawing of this component onto the scene after post processing (only applies to editor drawing)
  **/
  @:uproperty public var bUseEditorCompositing : Bool;
  
  /**
    If this is True, this component must always be loaded on servers, even if Hidden and CollisionEnabled is NoCollision
  **/
  @:uproperty public var AlwaysLoadOnServer : Bool;
  
  /**
    If this is True, this component must always be loaded on clients, even if Hidden and CollisionEnabled is NoCollision.
  **/
  @:uproperty public var AlwaysLoadOnClient : Bool;
  
  /**
    True if physics should be replicated to autonomous proxies. This should be true for
                  server-authoritative simulations, and false for client authoritative simulations.
  **/
  @:uproperty public var bReplicatePhysicsToAutonomousProxy : Bool;
  
  /**
    True for damage to this component to apply physics impulse, false to opt out of these impulses.
  **/
  @:uproperty public var bApplyImpulseOnDamage : Bool;
  
  /**
    Will ignore radial forces applied to this component.
  **/
  @:uproperty public var bIgnoreRadialForce : Bool;
  
  /**
    Will ignore radial impulses applied to this component.
  **/
  @:uproperty public var bIgnoreRadialImpulse : Bool;
  
  /**
    Whether the whole component should be shadowed as one from stationary lights, which makes shadow receiving much cheaper.
    When enabled shadowing data comes from the volume lighting samples precomputed by Lightmass, which are very sparse.
    This is currently only used on stationary directional lights.
  **/
  @:uproperty public var bSingleSampleShadowFromStationaryLights : Bool;
  
  /**
    Mobile only:
    If disabled this component will not receive CSM shadows. (Components that do not receive CSM may have reduced shading cost)
  **/
  @:uproperty public var bReceiveMobileCSMShadows : Bool;
  
  /**
    Whether to light this component and any attachments as a group.  This only has effect on the root component of an attachment tree.
    When enabled, attached component shadowing settings like bCastInsetShadow, bCastVolumetricTranslucentShadow, etc, will be ignored.
    This is useful for improving performance when multiple movable components are attached together.
  **/
  @:uproperty public var bLightAttachmentsAsGroup : Bool;
  @:deprecated @:uproperty public var bLightAsIfStatic_DEPRECATED : Bool;
  
  /**
    Whether this primitive should cast dynamic shadows as if it were a two sided material.
  **/
  @:uproperty public var bCastShadowAsTwoSided : Bool;
  
  /**
    If true, the primitive will cast shadows even if bHidden is true.
    Controls whether the primitive should cast shadows when hidden.
    This flag is only used if CastShadow is true.
  **/
  @:uproperty public var bCastHiddenShadow : Bool;
  
  /**
    Whether this component should cast shadows from lights that have bCastShadowsFromCinematicObjectsOnly enabled.
    This is useful for characters in a cinematic with special cinematic lights, where the cost of shadowmap rendering of the environment is undesired.
  **/
  @:uproperty public var bCastCinematicShadow : Bool;
  
  /**
    Whether this component should create a per-object shadow that gives higher effective shadow resolution.
    Useful for cinematic character shadowing. Assumed to be enabled if bSelfShadowOnly is enabled.
  **/
  @:uproperty public var bCastInsetShadow : Bool;
  
  /**
    When enabled, the component will be rendering into the far shadow cascades (only for directional lights).
  **/
  @:uproperty public var bCastFarShadow : Bool;
  
  /**
    When enabled, the component will only cast a shadow on itself and not other components in the world.
    This is especially useful for first person weapons, and forces bCastInsetShadow to be enabled.
  **/
  @:uproperty public var bSelfShadowOnly : Bool;
  
  /**
    Whether the object should cast a volumetric translucent shadow.
    Volumetric translucent shadows are useful for primitives with smoothly changing opacity like particles representing a volume,
    But have artifacts when used on highly opaque surfaces.
  **/
  @:uproperty public var bCastVolumetricTranslucentShadow : Bool;
  
  /**
    Whether the object should cast a static shadow from shadow casting lights.  This flag is only used if CastShadow is true.
  **/
  @:uproperty public var bCastStaticShadow : Bool;
  
  /**
    Controls whether the primitive should cast shadows in the case of non precomputed shadowing.  This flag is only used if CastShadow is true. *
  **/
  @:uproperty public var bCastDynamicShadow : Bool;
  
  /**
    Controls whether the primitive should affect dynamic distance field lighting methods.  This flag is only used if CastShadow is true. *
  **/
  @:uproperty public var bAffectDistanceFieldLighting : Bool;
  
  /**
    Controls whether the primitive should inject light into the Light Propagation Volume.  This flag is only used if CastShadow is true. *
  **/
  @:uproperty public var bAffectDynamicIndirectLighting : Bool;
  
  /**
    Controls whether the primitive component should cast a shadow or not.
    
    This flag is ignored (no shadows will be generated) if all materials on this component have an Unlit shading model.
  **/
  @:uproperty public var CastShadow : Bool;
  
  /**
    If true a hit-proxy will be generated for each instance of instanced static meshes
  **/
  @:uproperty public var bHasPerInstanceHitProxies : Bool;
  
  /**
    If true, forces mips for textures used by this component to be resident when this component's level is loaded.
  **/
  @:uproperty public var bForceMipStreaming : Bool;
  
  /**
    If this is True, this component can be selected in the editor.
  **/
  @:uproperty public var bSelectable : Bool;
  
  /**
    Whether to render the primitive in the depth only pass.
    This should generally be true for all objects, and let the renderer make decisions about whether to render objects in the depth only pass.
    @todo - if any rendering features rely on a complete depth only pass, this variable needs to go away.
  **/
  @:uproperty public var bUseAsOccluder : Bool;
  
  /**
    Treat this primitive as part of the background for occlusion purposes. This can be used as an optimization to reduce the cost of rendering skyboxes, large ground planes that are part of the vista, etc.
  **/
  @:uproperty public var bTreatAsBackgroundForOcclusion : Bool;
  
  /**
    If this is True, this component will only be visible when the view actor is the component's owner, directly or indirectly.
  **/
  @:uproperty public var bOnlyOwnerSee : Bool;
  
  /**
    If this is True, this component won't be visible when the view actor is the component's owner, directly or indirectly.
  **/
  @:uproperty public var bOwnerNoSee : Bool;
  
  /**
    Whether the primitive receives decals.
  **/
  @:uproperty public var bReceivesDecals : Bool;
  
  /**
    If true, this component will be rendered in mono only if an HMD is connected and monoscopic far field rendering is activated.
  **/
  @:uproperty public var bRenderInMono : Bool;
  
  /**
    If true, this component will be rendered in the main pass (z prepass, basepass, transparency)
  **/
  @:uproperty public var bRenderInMainPass : Bool;
  
  /**
    If true, this component will be visible in reflection captures.
  **/
  @:uproperty public var bVisibleInReflectionCaptures : Bool;
  
  /**
    true if the primitive has motion blur velocity meshes
  **/
  @:uproperty public var bHasMotionBlurVelocityMeshes : Bool;
  
  /**
    Whether to accept cull distance volumes to modify cached cull distance.
  **/
  @:uproperty public var bAllowCullDistanceVolume : Bool;
  
  /**
    True if the primitive should be rendered using ViewOwnerDepthPriorityGroup if viewed by its owner.
  **/
  @:uproperty public var bUseViewOwnerDepthPriorityGroup : Bool;
  
  /**
    If true, component sweeps will return the material in their hit result.
    @see MoveComponent(), FHitResult
  **/
  @:uproperty public var bReturnMaterialOnMove : Bool;
  
  /**
    If true, component sweeps with this component should trace against complex collision during movement (for example, each triangle of a mesh).
    If false, collision will be resolved against simple collision bounds instead.
    @see MoveComponent()
  **/
  @:uproperty public var bTraceComplexOnMove : Bool;
  
  /**
    If true, this component will look for collisions on both physic scenes during movement.
    Only required if the asynchronous physics scene is enabled and has geometry in it, and you wish to test for collisions with objects in that scene.
    @see MoveComponent()
  **/
  @:uproperty public var bCheckAsyncSceneOnMove : Bool;
  
  /**
    If true, this component will generate individual overlaps for each overlapping physics body if it is a multi-body component. When false, this component will
    generate only one overlap, regardless of how many physics bodies it has and how many of them are overlapping another component/body. This flag has no
    influence on single body components.
  **/
  @:uproperty public var bMultiBodyOverlap : Bool;
  
  /**
    Indicates if we'd like to create physics state all the time (for collision and simulation).
    If you set this to false, it still will create physics state if collision or simulation activated.
    This can help performance if you'd like to avoid overhead of creating physics state when triggers
  **/
  @:uproperty public var bAlwaysCreatePhysicsState : Bool;
  
  /**
    When enabled this object will not be culled by distance. This is ignored if a child of a HLOD.
  **/
  @:uproperty public var bNeverDistanceCull : Bool;
  #if WITH_EDITORONLY_DATA
  
  /**
    Which specific HLOD levels this component should be excluded from
  **/
  @:uproperty public var ExcludeForSpecificHLODLevels : unreal.TArray<unreal.Int32>;
  
  /**
    Use the Maximum LOD Mesh (imposter) instead of including Mesh data from this component in the Proxy Generation process
  **/
  @:uproperty public var bUseMaxLODAsImposter : Bool;
  
  /**
    If true, and if World setting has bEnableHierarchicalLOD equal to true, then this component will be included when generating a Proxy mesh for the parent Actor
  **/
  @:uproperty public var bEnableAutoLODGeneration : Bool;
  #end // WITH_EDITORONLY_DATA
  
  /**
    Controls the type of lightmap used for this component.
  **/
  @:uproperty public var LightmapType : unreal.ELightmapType;
  
  /**
    Quality of indirect lighting for Movable primitives.  This has a large effect on Indirect Lighting Cache update time.
  **/
  @:uproperty public var IndirectLightingCacheQuality : unreal.EIndirectLightingCacheQuality;
  
  /**
    The scene depth priority group to draw the primitive in, if it's being viewed by its owner.
  **/
  @:uproperty public var ViewOwnerDepthPriorityGroup : unreal.ESceneDepthPriorityGroup;
  
  /**
    The scene depth priority group to draw the primitive in.
  **/
  @:uproperty public var DepthPriorityGroup : unreal.ESceneDepthPriorityGroup;
  
  /**
    The distance to cull this primitive at.
    A CachedMaxDrawDistance of 0 indicates that the primitive should not be culled by distance.
  **/
  @:uproperty public var CachedMaxDrawDistance : unreal.Float32;
  
  /**
    Max draw distance exposed to LDs. The real max draw distance is the min (disregarding 0) of this and volumes affecting this object.
  **/
  @:uproperty public var LDMaxDrawDistance : unreal.Float32;
  
  /**
    The minimum distance at which the primitive should be rendered,
    measured in world space units from the center of the primitive's bounding sphere to the camera position.
  **/
  @:uproperty public var MinDrawDistance : unreal.Float32;
  
  /**
    If true, this component will generate overlap events when it is overlapping other components (eg Begin Overlap).
    Both components (this and the other) must have this enabled for overlap events to occur.
    
    @see [Overlap Events](https://docs.unrealengine.com/latest/INT/Engine/Physics/Collision/index.html#overlapandgenerateoverlapevents)
    @see UpdateOverlaps(), BeginComponentOverlap(), EndComponentOverlap()
  **/
  @:ufunction(BlueprintCallable) @:thisConst @:final public function GetGenerateOverlapEvents() : Bool;
  @:ufunction(BlueprintCallable) @:final public function SetGenerateOverlapEvents(bInGenerateOverlapEvents : Bool) : Void;
  
  /**
    Tells this component whether to ignore collision with all components of a specific Actor when this component is moved.
    Components on the other Actor may also need to be told to do the same when they move.
    Does not affect movement of this component when simulating physics.
  **/
  @:ufunction(BlueprintCallable) @:final public function IgnoreActorWhenMoving(Actor : unreal.AActor, bShouldIgnore : Bool) : Void;
  
  /**
    Returns the list of actors we currently ignore when moving.
  **/
  @:ufunction(BlueprintCallable) @:final public function CopyArrayOfMoveIgnoreActors() : unreal.TArray<unreal.AActor>;
  
  /**
    Clear the list of actors we ignore when moving.
  **/
  @:ufunction(BlueprintCallable) @:final public function ClearMoveIgnoreActors() : Void;
  
  /**
    Tells this component whether to ignore collision with another component when this component is moved.
    The other components may also need to be told to do the same when they move.
    Does not affect movement of this component when simulating physics.
  **/
  @:ufunction(BlueprintCallable) @:final public function IgnoreComponentWhenMoving(Component : unreal.UPrimitiveComponent, bShouldIgnore : Bool) : Void;
  
  /**
    Returns the list of actors we currently ignore when moving.
  **/
  @:ufunction(BlueprintCallable) @:final public function CopyArrayOfMoveIgnoreComponents() : unreal.TArray<unreal.UPrimitiveComponent>;
  
  /**
    Clear the list of components we ignore when moving.
  **/
  @:ufunction(BlueprintCallable) @:final public function ClearMoveIgnoreComponents() : Void;
  
  /**
    Check whether this component is overlapping another component.
    @param OtherComp Component to test this component against.
    @return Whether this component is overlapping another component.
  **/
  @:ufunction(BlueprintCallable) @:thisConst @:final public function IsOverlappingComponent(OtherComp : unreal.Const<unreal.UPrimitiveComponent>) : Bool;
  
  /**
    Check whether this component is overlapping any component of the given Actor.
    @param Other Actor to test this component against.
    @return Whether this component is overlapping any component of the given Actor.
  **/
  @:ufunction(BlueprintCallable) @:thisConst @:final public function IsOverlappingActor(Other : unreal.Const<unreal.AActor>) : Bool;
  
  /**
    Returns a list of actors that this component is overlapping.
    @param OverlappingActors             [out] Returned list of overlapping actors
    @param ClassFilter                   [optional] If set, only returns actors of this class or subclasses
  **/
  @:ufunction(BlueprintCallable) @:thisConst @:final public function GetOverlappingActors(OverlappingActors : unreal.PRef<unreal.TArray<unreal.AActor>>, @:opt("None") ClassFilter : unreal.TSubclassOf<unreal.AActor>) : Void;
  
  /**
    Returns unique list of components this component is overlapping.
  **/
  @:ufunction(BlueprintCallable) @:thisConst @:final public function GetOverlappingComponents(OutOverlappingComponents : unreal.PRef<unreal.TArray<unreal.UPrimitiveComponent>>) : Void;
  
  /**
    Scale the bounds of this object, used for frustum culling. Useful for features like WorldPositionOffset.
  **/
  @:ufunction(BlueprintCallable) @:final public function SetBoundsScale(NewBoundsScale : unreal.Float32 = 1.000000) : Void;
  
  /**
    Returns the material used by the element at the specified index
    @param ElementIndex - The element to access the material of.
    @return the material used by the indexed element of this mesh.
  **/
  @:ufunction(BlueprintCallable) @:thisConst public function GetMaterial(ElementIndex : unreal.Int32) : unreal.UMaterialInterface;
  
  /**
    Changes the material applied to an element of the mesh.
    @param ElementIndex - The element to access the material of.
    @return the material used by the indexed element of this mesh.
  **/
  @:ufunction(BlueprintCallable) public function SetMaterial(ElementIndex : unreal.Int32, Material : unreal.UMaterialInterface) : Void;
  
  /**
    Changes the material applied to an element of the mesh.
    @param MaterialSlotName - The slot name to access the material of.
    @return the material used by the indexed element of this mesh.
  **/
  @:ufunction(BlueprintCallable) public function SetMaterialByName(MaterialSlotName : unreal.FName, Material : unreal.UMaterialInterface) : Void;
  
  /**
    Creates a Dynamic Material Instance for the specified element index.  The parent of the instance is set to the material being replaced.
    @param ElementIndex - The index of the skin to replace the material for.  If invalid, the material is unchanged and NULL is returned.
  **/
  @:ufunction(BlueprintCallable) public function CreateAndSetMaterialInstanceDynamic(ElementIndex : unreal.Int32) : unreal.UMaterialInstanceDynamic;
  
  /**
    Creates a Dynamic Material Instance for the specified element index.  The parent of the instance is set to the material being replaced.
    @param ElementIndex - The index of the skin to replace the material for.  If invalid, the material is unchanged and NULL is returned.
  **/
  @:ufunction(BlueprintCallable) public function CreateAndSetMaterialInstanceDynamicFromMaterial(ElementIndex : unreal.Int32, Parent : unreal.UMaterialInterface) : unreal.UMaterialInstanceDynamic;
  
  /**
    Creates a Dynamic Material Instance for the specified element index, optionally from the supplied material.
    @param ElementIndex - The index of the skin to replace the material for.  If invalid, the material is unchanged and NULL is returned.
  **/
  @:ufunction(BlueprintCallable) public function CreateDynamicMaterialInstance(ElementIndex : unreal.Int32, @:opt("None") SourceMaterial : unreal.UMaterialInterface, @:opt("None") OptionalName : unreal.FName) : unreal.UMaterialInstanceDynamic;
  
  /**
    Try and retrieve the material applied to a particular collision face of mesh. Used with face index returned from collision trace.
         @param  FaceIndex               Face index from hit result that was hit by a trace
         @param  SectionIndex    Section of the mesh that the face belongs to
         @return                                 Material applied to section that the hit face belongs to
  **/
  @:ufunction(BlueprintCallable) @:thisConst public function GetMaterialFromCollisionFaceIndex(FaceIndex : unreal.Int32, SectionIndex : unreal.Int32) : unreal.UMaterialInterface;
  
  /**
    Returns the slope override struct for this component.
  **/
  @:ufunction(BlueprintCallable) @:thisConst @:final public function GetWalkableSlopeOverride() : unreal.Const<unreal.PRef<unreal.FWalkableSlopeOverride>>;
  
  /**
    Sets a new slope override for this component instance.
  **/
  @:ufunction(BlueprintCallable) @:final public function SetWalkableSlopeOverride(NewOverride : unreal.Const<unreal.PRef<unreal.FWalkableSlopeOverride>>) : Void;
  
  /**
    Sets whether or not a single body should use physics simulation, or should be 'fixed' (kinematic).
    Note that if this component is currently attached to something, beginning simulation will detach it.
    
    @param  bSimulate       New simulation state for single body
  **/
  @:ufunction(BlueprintCallable) public function SetSimulatePhysics(bSimulate : Bool) : Void;
  @:ufunction(BlueprintCallable) public function SetLockedAxis(LockedAxis : unreal.EDOFMode) : Void;
  
  /**
    Sets the constraint mode of the component.
    @param ConstraintMode        The type of constraint to use.
  **/
  @:ufunction(BlueprintCallable) public function SetConstraintMode(ConstraintMode : unreal.EDOFMode) : Void;
  
  /**
    Add an impulse to a single rigid body. Good for one time instant burst.
    
    @param  Impulse         Magnitude and direction of impulse to apply.
    @param  BoneName        If a SkeletalMeshComponent, name of body to apply impulse to. 'None' indicates root body.
    @param  bVelChange      If true, the Strength is taken as a change in velocity instead of an impulse (ie. mass will have no effect).
  **/
  @:ufunction(BlueprintCallable) public function AddImpulse(Impulse : unreal.FVector, @:opt("None") BoneName : unreal.FName, bVelChange : Bool = false) : Void;
  @:ufunction(BlueprintCallable) public function AddAngularImpulse(Impulse : unreal.FVector, @:opt("None") BoneName : unreal.FName, bVelChange : Bool = false) : Void;
  
  /**
    Add an angular impulse to a single rigid body. Good for one time instant burst.
    
    @param  AngularImpulse  Magnitude and direction of impulse to apply. Direction is axis of rotation.
    @param  BoneName        If a SkeletalMeshComponent, name of body to apply angular impulse to. 'None' indicates root body.
    @param  bVelChange      If true, the Strength is taken as a change in angular velocity instead of an impulse (ie. mass will have no effect).
  **/
  @:ufunction(BlueprintCallable) public function AddAngularImpulseInRadians(Impulse : unreal.FVector, @:opt("None") BoneName : unreal.FName, bVelChange : Bool = false) : Void;
  
  /**
    Add an angular impulse to a single rigid body. Good for one time instant burst.
    
    @param  AngularImpulse  Magnitude and direction of impulse to apply. Direction is axis of rotation.
    @param  BoneName        If a SkeletalMeshComponent, name of body to apply angular impulse to. 'None' indicates root body.
    @param  bVelChange      If true, the Strength is taken as a change in angular velocity instead of an impulse (ie. mass will have no effect).
  **/
  @:ufunction(BlueprintCallable) @:final public function AddAngularImpulseInDegrees(Impulse : unreal.FVector, @:opt("None") BoneName : unreal.FName, bVelChange : Bool = false) : Void;
  
  /**
    Add an impulse to a single rigid body at a specific location.
    
    @param  Impulse         Magnitude and direction of impulse to apply.
    @param  Location        Point in world space to apply impulse at.
    @param  BoneName        If a SkeletalMeshComponent, name of bone to apply impulse to. 'None' indicates root body.
  **/
  @:ufunction(BlueprintCallable) public function AddImpulseAtLocation(Impulse : unreal.FVector, Location : unreal.FVector, @:opt("None") BoneName : unreal.FName) : Void;
  
  /**
    Add an impulse to all rigid bodies in this component, radiating out from the specified position.
    
    @param Origin                Point of origin for the radial impulse blast, in world space
    @param Radius                Size of radial impulse. Beyond this distance from Origin, there will be no affect.
    @param Strength              Maximum strength of impulse applied to body.
    @param Falloff               Allows you to control the strength of the impulse as a function of distance from Origin.
    @param bVelChange    If true, the Strength is taken as a change in velocity instead of an impulse (ie. mass will have no effect).
  **/
  @:ufunction(BlueprintCallable) public function AddRadialImpulse(Origin : unreal.FVector, Radius : unreal.Float32, Strength : unreal.Float32, Falloff : unreal.ERadialImpulseFalloff, bVelChange : Bool = false) : Void;
  
  /**
    Add a force to a single rigid body.
    This is like a 'thruster'. Good for adding a burst over some (non zero) time. Should be called every frame for the duration of the force.
    
    @param  Force            Force vector to apply. Magnitude indicates strength of force.
    @param  BoneName         If a SkeletalMeshComponent, name of body to apply force to. 'None' indicates root body.
    @param  bAccelChange If true, Force is taken as a change in acceleration instead of a physical force (i.e. mass will have no effect).
  **/
  @:ufunction(BlueprintCallable) public function AddForce(Force : unreal.FVector, @:opt("None") BoneName : unreal.FName, bAccelChange : Bool = false) : Void;
  
  /**
    Add a force to a single rigid body at a particular location in world space.
    This is like a 'thruster'. Good for adding a burst over some (non zero) time. Should be called every frame for the duration of the force.
    
    @param Force            Force vector to apply. Magnitude indicates strength of force.
    @param Location         Location to apply force, in world space.
    @param BoneName         If a SkeletalMeshComponent, name of body to apply force to. 'None' indicates root body.
  **/
  @:ufunction(BlueprintCallable) public function AddForceAtLocation(Force : unreal.FVector, Location : unreal.FVector, @:opt("None") BoneName : unreal.FName) : Void;
  
  /**
    Add a force to a single rigid body at a particular location. Both Force and Location should be in body space.
    This is like a 'thruster'. Good for adding a burst over some (non zero) time. Should be called every frame for the duration of the force.
    
    @param Force            Force vector to apply. Magnitude indicates strength of force.
    @param Location         Location to apply force, in component space.
    @param BoneName         If a SkeletalMeshComponent, name of body to apply force to. 'None' indicates root body.
  **/
  @:ufunction(BlueprintCallable) public function AddForceAtLocationLocal(Force : unreal.FVector, Location : unreal.FVector, @:opt("None") BoneName : unreal.FName) : Void;
  
  /**
    Add a force to all bodies in this component, originating from the supplied world-space location.
    
    @param Origin           Origin of force in world space.
    @param Radius           Radius within which to apply the force.
    @param Strength         Strength of force to apply.
    @param Falloff              Allows you to control the strength of the force as a function of distance from Origin.
    @param bAccelChange If true, Strength is taken as a change in acceleration instead of a physical force (i.e. mass will have no effect).
  **/
  @:ufunction(BlueprintCallable) public function AddRadialForce(Origin : unreal.FVector, Radius : unreal.Float32, Strength : unreal.Float32, Falloff : unreal.ERadialImpulseFalloff, bAccelChange : Bool = false) : Void;
  @:ufunction(BlueprintCallable) @:final public function AddTorque(Torque : unreal.FVector, @:opt("None") BoneName : unreal.FName, bAccelChange : Bool = false) : Void;
  
  /**
    Add a torque to a single rigid body.
    @param Torque           Torque to apply. Direction is axis of rotation and magnitude is strength of torque.
    @param BoneName         If a SkeletalMeshComponent, name of body to apply torque to. 'None' indicates root body.
    @param bAccelChange If true, Torque is taken as a change in angular acceleration instead of a physical torque (i.e. mass will have no effect).
  **/
  @:ufunction(BlueprintCallable) public function AddTorqueInRadians(Torque : unreal.FVector, @:opt("None") BoneName : unreal.FName, bAccelChange : Bool = false) : Void;
  
  /**
    Add a torque to a single rigid body.
    @param Torque           Torque to apply. Direction is axis of rotation and magnitude is strength of torque.
    @param BoneName         If a SkeletalMeshComponent, name of body to apply torque to. 'None' indicates root body.
    @param bAccelChange If true, Torque is taken as a change in angular acceleration instead of a physical torque (i.e. mass will have no effect).
  **/
  @:ufunction(BlueprintCallable) @:final public function AddTorqueInDegrees(Torque : unreal.FVector, @:opt("None") BoneName : unreal.FName, bAccelChange : Bool = false) : Void;
  
  /**
    Set the linear velocity of a single body.
    This should be used cautiously - it may be better to use AddForce or AddImpulse.
    
    @param NewVel                   New linear velocity to apply to physics.
    @param bAddToCurrent    If true, NewVel is added to the existing velocity of the body.
    @param BoneName                 If a SkeletalMeshComponent, name of body to modify velocity of. 'None' indicates root body.
  **/
  @:ufunction(BlueprintCallable) public function SetPhysicsLinearVelocity(NewVel : unreal.FVector, bAddToCurrent : Bool = false, @:opt("None") BoneName : unreal.FName) : Void;
  
  /**
    Get the linear velocity of a single body.
    @param BoneName                 If a SkeletalMeshComponent, name of body to get velocity of. 'None' indicates root body.
  **/
  @:ufunction(BlueprintCallable) @:final public function GetPhysicsLinearVelocity(@:opt("None") BoneName : unreal.FName) : unreal.FVector;
  
  /**
    Get the linear velocity of a point on a single body.
    @param Point                    Point is specified in world space.
    @param BoneName                 If a SkeletalMeshComponent, name of body to get velocity of. 'None' indicates root body.
  **/
  @:ufunction(BlueprintCallable) @:final public function GetPhysicsLinearVelocityAtPoint(Point : unreal.FVector, @:opt("None") BoneName : unreal.FName) : unreal.FVector;
  
  /**
    Set the linear velocity of all bodies in this component.
    
    @param NewVel                   New linear velocity to apply to physics.
    @param bAddToCurrent    If true, NewVel is added to the existing velocity of the body.
  **/
  @:ufunction(BlueprintCallable) public function SetAllPhysicsLinearVelocity(NewVel : unreal.FVector, bAddToCurrent : Bool = false) : Void;
  @:ufunction(BlueprintCallable) @:final public function SetPhysicsAngularVelocity(NewAngVel : unreal.FVector, bAddToCurrent : Bool = false, @:opt("None") BoneName : unreal.FName) : Void;
  
  /**
    Set the angular velocity of a single body.
    This should be used cautiously - it may be better to use AddTorque or AddImpulse.
    
    @param NewAngVel                New angular velocity to apply to body, in radians per second.
    @param bAddToCurrent    If true, NewAngVel is added to the existing angular velocity of the body.
    @param BoneName                 If a SkeletalMeshComponent, name of body to modify angular velocity of. 'None' indicates root body.
  **/
  @:ufunction(BlueprintCallable) public function SetPhysicsAngularVelocityInRadians(NewAngVel : unreal.FVector, bAddToCurrent : Bool = false, @:opt("None") BoneName : unreal.FName) : Void;
  
  /**
    Set the angular velocity of a single body.
    This should be used cautiously - it may be better to use AddTorque or AddImpulse.
    
    @param NewAngVel                New angular velocity to apply to body, in degrees per second.
    @param bAddToCurrent    If true, NewAngVel is added to the existing angular velocity of the body.
    @param BoneName                 If a SkeletalMeshComponent, name of body to modify angular velocity of. 'None' indicates root body.
  **/
  @:ufunction(BlueprintCallable) @:final public function SetPhysicsAngularVelocityInDegrees(NewAngVel : unreal.FVector, bAddToCurrent : Bool = false, @:opt("None") BoneName : unreal.FName) : Void;
  @:ufunction(BlueprintCallable) @:final public function SetPhysicsMaxAngularVelocity(NewMaxAngVel : unreal.Float32, bAddToCurrent : Bool = false, @:opt("None") BoneName : unreal.FName) : Void;
  
  /**
    Set the maximum angular velocity of a single body.
    
    @param NewMaxAngVel             New maximum angular velocity to apply to body, in degrees per second.
    @param bAddToCurrent    If true, NewMaxAngVel is added to the existing maximum angular velocity of the body.
    @param BoneName                 If a SkeletalMeshComponent, name of body to modify maximum angular velocity of. 'None' indicates root body.
  **/
  @:ufunction(BlueprintCallable) @:final public function SetPhysicsMaxAngularVelocityInDegrees(NewMaxAngVel : unreal.Float32, bAddToCurrent : Bool = false, @:opt("None") BoneName : unreal.FName) : Void;
  
  /**
    Set the maximum angular velocity of a single body.
    
    @param NewMaxAngVel             New maximum angular velocity to apply to body, in radians per second.
    @param bAddToCurrent    If true, NewMaxAngVel is added to the existing maximum angular velocity of the body.
    @param BoneName                 If a SkeletalMeshComponent, name of body to modify maximum angular velocity of. 'None' indicates root body.
  **/
  @:ufunction(BlueprintCallable) @:final public function SetPhysicsMaxAngularVelocityInRadians(NewMaxAngVel : unreal.Float32, bAddToCurrent : Bool = false, @:opt("None") BoneName : unreal.FName) : Void;
  @:ufunction(BlueprintCallable) @:thisConst @:final public function GetPhysicsAngularVelocity(@:opt("None") BoneName : unreal.FName) : unreal.FVector;
  
  /**
    Get the angular velocity of a single body, in degrees per second.
    @param BoneName                 If a SkeletalMeshComponent, name of body to get velocity of. 'None' indicates root body.
  **/
  @:ufunction(BlueprintCallable) @:thisConst @:final public function GetPhysicsAngularVelocityInDegrees(@:opt("None") BoneName : unreal.FName) : unreal.FVector;
  
  /**
    Get the angular velocity of a single body, in radians per second.
    @param BoneName                 If a SkeletalMeshComponent, name of body to get velocity of. 'None' indicates root body.
  **/
  @:ufunction(BlueprintCallable) @:thisConst @:final public function GetPhysicsAngularVelocityInRadians(@:opt("None") BoneName : unreal.FName) : unreal.FVector;
  
  /**
    Get the center of mass of a single body. In the case of a welded body this will return the center of mass of the entire welded body (including its parent and children)
    Objects that are not simulated return (0,0,0) as they do not have COM
    @param BoneName                 If a SkeletalMeshComponent, name of body to get center of mass of. 'None' indicates root body.
  **/
  @:ufunction(BlueprintCallable) @:thisConst @:final public function GetCenterOfMass(@:opt("None") BoneName : unreal.FName) : unreal.FVector;
  
  /**
    Set the center of mass of a single body. This will offset the physx-calculated center of mass.
    Note that in the case where multiple bodies are attached together, the center of mass will be set for the entire group.
    @param CenterOfMassOffset               User specified offset for the center of mass of this object, from the calculated location.
    @param BoneName                 If a SkeletalMeshComponent, name of body to set center of mass of. 'None' indicates root body.
  **/
  @:ufunction(BlueprintCallable) @:final public function SetCenterOfMass(CenterOfMassOffset : unreal.FVector, @:opt("None") BoneName : unreal.FName) : Void;
  
  /**
    'Wake' physics simulation for a single body.
    @param  BoneName        If a SkeletalMeshComponent, name of body to wake. 'None' indicates root body.
  **/
  @:ufunction(BlueprintCallable) public function WakeRigidBody(@:opt("None") BoneName : unreal.FName) : Void;
  
  /**
    Force a single body back to sleep.
    @param  BoneName        If a SkeletalMeshComponent, name of body to put to sleep. 'None' indicates root body.
  **/
  @:ufunction(BlueprintCallable) @:final public function PutRigidBodyToSleep(@:opt("None") BoneName : unreal.FName) : Void;
  
  /**
    Changes the value of bNotifyRigidBodyCollision
    @param bNewNotifyRigidBodyCollision - The value to assign to bNotifyRigidBodyCollision
  **/
  @:ufunction(BlueprintCallable) public function SetNotifyRigidBodyCollision(bNewNotifyRigidBodyCollision : Bool) : Void;
  
  /**
    Changes the value of bOwnerNoSee.
  **/
  @:ufunction(BlueprintCallable) @:final public function SetOwnerNoSee(bNewOwnerNoSee : Bool) : Void;
  
  /**
    Changes the value of bOnlyOwnerSee.
  **/
  @:ufunction(BlueprintCallable) @:final public function SetOnlyOwnerSee(bNewOnlyOwnerSee : Bool) : Void;
  
  /**
    Changes the value of CastShadow.
  **/
  @:ufunction(BlueprintCallable) @:final public function SetCastShadow(NewCastShadow : Bool) : Void;
  
  /**
    Changes the value of bSingleSampleShadowFromStationaryLights.
  **/
  @:ufunction(BlueprintCallable) @:final public function SetSingleSampleShadowFromStationaryLights(bNewSingleSampleShadowFromStationaryLights : Bool) : Void;
  
  /**
    Changes the value of TranslucentSortPriority.
  **/
  @:ufunction(BlueprintCallable) @:final public function SetTranslucentSortPriority(NewTranslucentSortPriority : unreal.Int32) : Void;
  
  /**
    Changes the value of bReceivesDecals.
  **/
  @:ufunction(BlueprintCallable) @:final public function SetReceivesDecals(bNewReceivesDecals : Bool) : Void;
  
  /**
    Controls what kind of collision is enabled for this body
  **/
  @:ufunction(BlueprintCallable) public function SetCollisionEnabled(NewType : unreal.ECollisionEnabled) : Void;
  
  /**
    Set Collision Profile Name
    This function is called by constructors when they set ProfileName
    This will change current CollisionProfileName to be this, and overwrite Collision Setting
    
    @param InCollisionProfileName : New Profile Name
  **/
  @:ufunction(BlueprintCallable) public function SetCollisionProfileName(InCollisionProfileName : unreal.FName) : Void;
  
  /**
    Get the collision profile name
  **/
  @:ufunction(BlueprintCallable) @:thisConst @:final public function GetCollisionProfileName() : unreal.FName;
  
  /**
    Changes the collision channel that this object uses when it moves
    @param      Channel     The new channel for this component to use
  **/
  @:ufunction(BlueprintCallable) public function SetCollisionObjectType(Channel : unreal.ECollisionChannel) : Void;
  
  /**
    Perform a line trace against a single component
    @param TraceStart The start of the trace in world-space
    @param TraceEnd The end of the trace in world-space
    @param bTraceComplex Whether or not to trace the complex physics representation or just the simple representation
    @param bShowTrace Whether or not to draw the trace in the world (for debugging)
    @param bPersistentShowTrace Whether or not to make the debugging draw stay in the world permanently
  **/
  @:ufunction(BlueprintCallable) @:final public function K2_LineTraceComponent(TraceStart : unreal.FVector, TraceEnd : unreal.FVector, @:bpopt("true") bTraceComplex : Bool, bShowTrace : Bool, @:bpopt("false") bPersistentShowTrace : Bool, HitLocation : unreal.PRef<unreal.FVector>, HitNormal : unreal.PRef<unreal.FVector>, BoneName : unreal.PRef<unreal.FName>, OutHit : unreal.PRef<unreal.FHitResult>) : Bool;
  
  /**
    Perform a sphere trace against a single component
    @param TraceStart The start of the trace in world-space
    @param TraceEnd The end of the trace in world-space
    @param SphereRadius Radius of the sphere to trace against the component
    @param bTraceComplex Whether or not to trace the complex physics representation or just the simple representation
    @param bShowTrace Whether or not to draw the trace in the world (for debugging)
    @param bPersistentShowTrace Whether or not to make the debugging draw stay in the world permanently
  **/
  @:ufunction(BlueprintCallable) @:final public function K2_SphereTraceComponent(TraceStart : unreal.FVector, TraceEnd : unreal.FVector, SphereRadius : unreal.Float32, @:bpopt("true") bTraceComplex : Bool, bShowTrace : Bool, @:bpopt("false") bPersistentShowTrace : Bool, HitLocation : unreal.PRef<unreal.FVector>, HitNormal : unreal.PRef<unreal.FVector>, BoneName : unreal.PRef<unreal.FName>, OutHit : unreal.PRef<unreal.FHitResult>) : Bool;
  
  /**
    Perform a box overlap against a single component as an AABB (No rotation)
    @param InBoxCentre The centre of the box to overlap with the component
    @param InBox Description of the box to use in the overlap
    @param bTraceComplex Whether or not to trace the complex physics representation or just the simple representation
    @param bShowTrace Whether or not to draw the trace in the world (for debugging)
    @param bPersistentShowTrace Whether or not to make the debugging draw stay in the world permanently
  **/
  @:ufunction(BlueprintCallable) @:final public function K2_BoxOverlapComponent(InBoxCentre : unreal.FVector, InBox : unreal.Const<unreal.FBox>, @:bpopt("true") bTraceComplex : Bool, bShowTrace : Bool, @:bpopt("false") bPersistentShowTrace : Bool, HitLocation : unreal.PRef<unreal.FVector>, HitNormal : unreal.PRef<unreal.FVector>, BoneName : unreal.PRef<unreal.FName>, OutHit : unreal.PRef<unreal.FHitResult>) : Bool;
  
  /**
    Perform a sphere overlap against a single component
    @param InSphereCentre The centre of the sphere to overlap with the component
    @param InSphereRadius The Radius of the sphere to overlap with the component
    @param bTraceComplex Whether or not to trace the complex physics representation or just the simple representation
    @param bShowTrace Whether or not to draw the trace in the world (for debugging)
    @param bPersistentShowTrace Whether or not to make the debugging draw stay in the world permanently
  **/
  @:ufunction(BlueprintCallable) @:final public function K2_SphereOverlapComponent(InSphereCentre : unreal.FVector, InSphereRadius : unreal.Float32, @:bpopt("true") bTraceComplex : Bool, bShowTrace : Bool, @:bpopt("false") bPersistentShowTrace : Bool, HitLocation : unreal.PRef<unreal.FVector>, HitNormal : unreal.PRef<unreal.FVector>, BoneName : unreal.PRef<unreal.FName>, OutHit : unreal.PRef<unreal.FHitResult>) : Bool;
  
  /**
    Sets the bRenderCustomDepth property and marks the render state dirty.
  **/
  @:ufunction(BlueprintCallable) @:final public function SetRenderCustomDepth(bValue : Bool) : Void;
  
  /**
    Sets the CustomDepth stencil value (0 - 255) and marks the render state dirty.
  **/
  @:ufunction(BlueprintCallable) @:final public function SetCustomDepthStencilValue(Value : unreal.Int32) : Void;
  
  /**
    Sets the CustomDepth stencil write mask and marks the render state dirty.
  **/
  @:ufunction(BlueprintCallable) @:final public function SetCustomDepthStencilWriteMask(WriteMaskBit : unreal.ERendererStencilMask) : Void;
  
  /**
    Sets bRenderInMainPass property and marks the render state dirty.
  **/
  @:ufunction(BlueprintCallable) @:final public function SetRenderInMainPass(bValue : Bool) : Void;
  
  /**
    Sets bRenderInMono property and marks the render state dirty.
  **/
  @:ufunction(BlueprintCallable) @:final public function SetRenderInMono(bValue : Bool) : Void;
  
  /**
    @return number of material elements in this primitive
  **/
  @:ufunction(BlueprintCallable) @:thisConst public function GetNumMaterials() : unreal.Int32;
  
  /**
    Returns the distance and closest point to the collision surface.
    Component must have simple collision to be queried for closest point.
    
    @param Point                          World 3D vector
    @param OutPointOnBody         Point on the surface of collision closest to Point
    @param BoneName                       If a SkeletalMeshComponent, name of body to set center of mass of. 'None' indicates root body.
    
    @return               Success if returns > 0.f, if returns 0.f, it is either not convex or inside of the point
                                  If returns < 0.f, this primitive does not have collsion
  **/
  @:ufunction(BlueprintCallable) @:thisConst @:final public function GetClosestPointOnCollision(Point : unreal.Const<unreal.PRef<unreal.FVector>>, OutPointOnBody : unreal.PRef<unreal.FVector>, @:opt("None") BoneName : unreal.FName) : unreal.Float32;
  
  /**
    Returns the form of collision for this component
  **/
  @:ufunction(BlueprintCallable) @:thisConst public function GetCollisionEnabled() : unreal.ECollisionEnabled;
  
  /**
    Utility to see if there is any form of collision (query or physics) enabled on this component.
  **/
  @:ufunction(BlueprintCallable) @:thisConst @:final public function K2_IsCollisionEnabled() : Bool;
  
  /**
    Utility to see if there is any query collision enabled on this component.
  **/
  @:ufunction(BlueprintCallable) @:thisConst @:final public function K2_IsQueryCollisionEnabled() : Bool;
  
  /**
    Utility to see if there is any physics collision enabled on this component.
  **/
  @:ufunction(BlueprintCallable) @:thisConst @:final public function K2_IsPhysicsCollisionEnabled() : Bool;
  
  /**
    Gets the response type given a specific channel
  **/
  @:ufunction(BlueprintCallable) @:thisConst public function GetCollisionResponseToChannel(Channel : unreal.ECollisionChannel) : unreal.ECollisionResponse;
  
  /**
    Gets the collision object type
  **/
  @:ufunction(BlueprintCallable) @:thisConst public function GetCollisionObjectType() : unreal.ECollisionChannel;
  @:ufunction(BlueprintCallable) public function SetAllPhysicsAngularVelocity(NewAngVel : unreal.Const<unreal.PRef<unreal.FVector>>, bAddToCurrent : Bool = false) : Void;
  
  /**
    Set the angular velocity of all bodies in this component.
    
    @param NewAngVel                New angular velocity to apply to physics, in degrees per second.
    @param bAddToCurrent    If true, NewAngVel is added to the existing angular velocity of all bodies.
  **/
  @:ufunction(BlueprintCallable) @:final public function SetAllPhysicsAngularVelocityInDegrees(NewAngVel : unreal.Const<unreal.PRef<unreal.FVector>>, bAddToCurrent : Bool = false) : Void;
  
  /**
    Set the angular velocity of all bodies in this component.
    
    @param NewAngVel                New angular velocity to apply to physics, in radians per second.
    @param bAddToCurrent    If true, NewAngVel is added to the existing angular velocity of all bodies.
  **/
  @:ufunction(BlueprintCallable) public function SetAllPhysicsAngularVelocityInRadians(NewAngVel : unreal.Const<unreal.PRef<unreal.FVector>>, bAddToCurrent : Bool = false) : Void;
  
  /**
    Ensure simulation is running for all bodies in this component.
  **/
  @:ufunction(BlueprintCallable) public function WakeAllRigidBodies() : Void;
  
  /**
    Enables/disables whether this component is affected by gravity. This applies only to components with bSimulatePhysics set to true.
  **/
  @:ufunction(BlueprintCallable) public function SetEnableGravity(bGravityEnabled : Bool) : Void;
  
  /**
    Returns whether this component is affected by gravity. Returns always false if the component is not simulated.
  **/
  @:ufunction(BlueprintCallable) @:thisConst public function IsGravityEnabled() : Bool;
  
  /**
    Sets the linear damping of this component.
  **/
  @:ufunction(BlueprintCallable) public function SetLinearDamping(InDamping : unreal.Float32) : Void;
  
  /**
    Returns the linear damping of this component.
  **/
  @:ufunction(BlueprintCallable) @:thisConst public function GetLinearDamping() : unreal.Float32;
  
  /**
    Sets the angular damping of this component.
  **/
  @:ufunction(BlueprintCallable) public function SetAngularDamping(InDamping : unreal.Float32) : Void;
  
  /**
    Returns the angular damping of this component.
  **/
  @:ufunction(BlueprintCallable) @:thisConst public function GetAngularDamping() : unreal.Float32;
  
  /**
    Change the mass scale used to calculate the mass of a single physics body
  **/
  @:ufunction(BlueprintCallable) public function SetMassScale(@:opt("None") BoneName : unreal.FName, InMassScale : unreal.Float32 = 1.000000) : Void;
  
  /**
    Returns the mass scale used to calculate the mass of a single physics body
  **/
  @:ufunction(BlueprintCallable) @:thisConst public function GetMassScale(@:opt("None") BoneName : unreal.FName) : unreal.Float32;
  
  /**
    Change the mass scale used fo all bodies in this component
  **/
  @:ufunction(BlueprintCallable) public function SetAllMassScale(InMassScale : unreal.Float32 = 1.000000) : Void;
  
  /**
    Override the mass (in Kg) of a single physics body.
    Note that in the case where multiple bodies are attached together, the override mass will be set for the entire group.
    Set the Override Mass to false if you want to reset the body's mass to the auto-calculated physx mass.
  **/
  @:ufunction(BlueprintCallable) public function SetMassOverrideInKg(@:opt("None") BoneName : unreal.FName, MassInKg : unreal.Float32 = 1.000000, bOverrideMass : Bool = true) : Void;
  
  /**
    Returns the mass of this component in kg.
  **/
  @:ufunction(BlueprintCallable) @:thisConst public function GetMass() : unreal.Float32;
  
  /**
    Returns the inertia tensor of this component in kg cm^2. The inertia tensor is in local component space.
  **/
  @:ufunction(BlueprintCallable) @:thisConst public function GetInertiaTensor(@:opt("None") BoneName : unreal.FName) : unreal.FVector;
  
  /**
    Scales the given vector by the world space moment of inertia. Useful for computing the torque needed to rotate an object.
  **/
  @:ufunction(BlueprintCallable) @:thisConst public function ScaleByMomentOfInertia(InputVector : unreal.FVector, @:opt("None") BoneName : unreal.FName) : unreal.FVector;
  
  /**
    Set whether this component should use Continuous Collision Detection
  **/
  @:ufunction(BlueprintCallable) public function SetUseCCD(InUseCCD : Bool, @:opt("None") BoneName : unreal.FName) : Void;
  
  /**
    Set whether all bodies in this component should use Continuous Collision Detection
  **/
  @:ufunction(BlueprintCallable) public function SetAllUseCCD(InUseCCD : Bool) : Void;
  
  /**
    Returns if any body in this component is currently awake and simulating.
  **/
  @:ufunction(BlueprintCallable) public function IsAnyRigidBodyAwake() : Bool;
  
  /**
    Changes a member of the ResponseToChannels container for this PrimitiveComponent.
    
    @param       Channel      The channel to change the response of
    @param       NewResponse  What the new response should be to the supplied Channel
  **/
  @:ufunction(BlueprintCallable) public function SetCollisionResponseToChannel(Channel : unreal.ECollisionChannel, NewResponse : unreal.ECollisionResponse) : Void;
  
  /**
    Changes all ResponseToChannels container for this PrimitiveComponent. to be NewResponse
    
    @param       NewResponse  What the new response should be to the supplied Channel
  **/
  @:ufunction(BlueprintCallable) public function SetCollisionResponseToAllChannels(NewResponse : unreal.ECollisionResponse) : Void;
  
  /**
    Changes the current PhysMaterialOverride for this component.
    Note that if physics is already running on this component, this will _not_ alter its mass/inertia etc,
    it will only change its surface properties like friction.
  **/
  @:ufunction(BlueprintCallable) public function SetPhysMaterialOverride(NewPhysMaterial : unreal.UPhysicalMaterial) : Void;
  
  /**
    Changes the value of CullDistance.
    @param NewCullDistance - The value to assign to CullDistance.
  **/
  @:ufunction(BlueprintCallable) @:final public function SetCullDistance(NewCullDistance : unreal.Float32) : Void;
  
  /**
    Return true if the given Pawn can step up onto this component.
    This controls whether they can try to step up on it when they bump in to it, not whether they can walk on it after landing on it.
    @param Pawn the Pawn that wants to step onto this component.
    @see CanCharacterStepUpOn
  **/
  @:ufunction(BlueprintCallable) @:thisConst public function CanCharacterStepUp(Pawn : unreal.APawn) : Bool;
  // NavRelevantInterface interface implementation
  
}
